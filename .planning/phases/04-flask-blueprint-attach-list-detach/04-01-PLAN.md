---
phase: 04-flask-blueprint-attach-list-detach
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/routes/rrid.py
  - backend/app/routes/publications.py
autonomous: true
requirements:
  - ATTACH-01
  - ATTACH-02
  - ATTACH-03
  - ATTACH-04
  - ATTACH-05
  - ATTACH-06
  - ATTACH-07
  - ATTACH-08
must_haves:
  truths:
    - "User can attach an RRID to a publication or organization via POST /api/v1/rrid/attach and receives the full serialized DocidRrid row"
    - "Attaching the same RRID to the same entity a second time returns HTTP 409 Conflict with a readable error message (not a 500 database error)"
    - "User can list all RRIDs attached to an entity via GET /api/v1/rrid/entity and receives a flat JSON array"
    - "User can remove an RRID via DELETE /api/v1/rrid/<rrid_id> and receives HTTP 200"
    - "Deleting a publication cascades to remove all associated docid_rrids rows for that publication"
    - "Deleting a publication_organization row cascades to remove its associated docid_rrids rows"
  artifacts:
    - path: "backend/app/routes/rrid.py"
      provides: "attach_rrid, list_entity_rrids, detach_rrid endpoint functions"
      contains: "POST.*attach|GET.*entity|DELETE.*rrid_id"
    - path: "backend/app/routes/publications.py"
      provides: "Cascade deletion of docid_rrids rows in delete_publication"
      contains: "DocidRrid.*filter_by.*entity_type"
  key_links:
    - from: "backend/app/routes/rrid.py"
      to: "app.service_scicrunch.resolve_rrid"
      via: "resolve_rrid() call in attach endpoint"
      pattern: "resolve_rrid\\("
    - from: "backend/app/routes/rrid.py"
      to: "app.models.DocidRrid"
      via: "db.session.add(new_rrid_record) and IntegrityError catch"
      pattern: "db\\.session\\.add|IntegrityError"
    - from: "backend/app/routes/rrid.py"
      to: "app.models.DocidRrid.get_rrids_for_entity"
      via: "class method call in list endpoint"
      pattern: "get_rrids_for_entity"
    - from: "backend/app/routes/publications.py"
      to: "app.models.DocidRrid"
      via: "cascade delete in delete_publication transaction"
      pattern: "DocidRrid\\.query\\.filter_by"
---

<objective>
Add three RRID lifecycle endpoints (attach, list, detach) to the existing rrid_bp blueprint, plus application-level cascade deletion in the publication and publication_organization delete flows.

Purpose: Complete the RRID data lifecycle so that RRIDs can be created, queried, and removed through the API, with data integrity maintained when parent entities are deleted.

Output: Three new Flask endpoints in rrid.py, cascade deletion logic in publications.py.
</objective>

<execution_context>
@/Users/ekariz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekariz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-flask-blueprint-attach-list-detach/04-CONTEXT.md
@.planning/phases/03-flask-blueprint-search-resolve/03-01-SUMMARY.md
@backend/app/routes/rrid.py
@backend/app/models.py
@backend/app/service_scicrunch.py
@backend/app/routes/publications.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add attach, list, and detach endpoints to rrid.py</name>
  <files>backend/app/routes/rrid.py</files>
  <action>
Add three new endpoint functions to the existing `rrid_bp` blueprint in `backend/app/routes/rrid.py`. All three require `@jwt_required()` consistent with the existing search and resolve endpoints.

**New imports needed at top of file:**
- `from app import db` (for session operations)
- `from sqlalchemy.exc import IntegrityError` (for duplicate detection)
- `validate_rrid` added to the existing `from app.service_scicrunch import ...` line

**1. POST /attach endpoint (`attach_rrid` function):**

- Route: `@rrid_bp.route('/attach', methods=['POST'])`
- Extract JSON body: `rrid`, `entity_type`, `entity_id`
- Validate all three fields present — missing any returns 400
- Validate `entity_type` against `DocidRrid.ALLOWED_ENTITY_TYPES` — invalid returns 400
- Validate `entity_id` is numeric (try int() conversion) — non-numeric returns 400
- Validate RRID format via `validate_rrid(rrid_value)` — invalid returns 400
- Call `resolve_rrid(validated_rrid)` WITHOUT entity context (no entity_type/entity_id params) — this is a fresh resolve, not a cache lookup. Per user decision: if SciCrunch is down, fail the request with HTTP 502 — do NOT create rows without resolved metadata.
- On resolve error: map "Invalid RRID format" to 400, "not found"/"could not resolve" to 404, other to 502 (same pattern as existing resolve endpoint)
- On resolve success: extract the 7 canonical fields from `resolved_result['resolved']` dict
- Create `DocidRrid` instance with: `entity_type`, `entity_id` (as int), `rrid` (the normalized/validated RRID string), `rrid_name` = resolved `name`, `rrid_description` = resolved `description`, `rrid_resource_type` = resolved `resource_type`, `rrid_url` = resolved `url`, `resolved_json` = the full resolved dict (all 7 fields), `last_resolved_at` = `datetime.utcnow()`
- `db.session.add()` then `db.session.commit()`
- Wrap the add/commit in try/except `IntegrityError` — on IntegrityError, `db.session.rollback()` then return 409 with message: `"{normalized_rrid} is already attached to this {entity_type}"` (per user decision — human-readable, entity-type-aware)
- On success, return the new row's `serialize()` output with HTTP 201
- Add Flasgger docstring following the existing pattern in the file

**2. GET /entity endpoint (`list_entity_rrids` function):**

- Route: `@rrid_bp.route('/entity', methods=['GET'])`
- Extract query params: `entity_type`, `entity_id`
- Both required — missing either returns 400 with message specifying which is missing
- Validate `entity_type` against `DocidRrid.ALLOWED_ENTITY_TYPES` — invalid returns 400
- Validate `entity_id` is numeric — non-numeric returns 400
- Call `DocidRrid.get_rrids_for_entity(entity_type, int(entity_id))` (the existing class method from Phase 1 that returns list ordered by created_at desc)
- Return `[row.serialize() for row in rrid_records]` as JSON with HTTP 200
- Empty result returns 200 with `[]` — no 204, consistent with Phase 3 search pattern
- No entity existence validation per user decision — just query and return what's there
- Add Flasgger docstring

**3. DELETE /<rrid_id> endpoint (`detach_rrid` function):**

- Route: `@rrid_bp.route('/<int:rrid_id>', methods=['DELETE'])`
- Look up: `DocidRrid.query.get(rrid_id)`
- Not found returns 404 with `{"error": "RRID record not found"}`
- Found: `db.session.delete(rrid_record)` then `db.session.commit()`
- Return `{"message": "RRID detached successfully"}` with HTTP 200
- No ownership checks per user decision — any authenticated user can delete any RRID
- Add Flasgger docstring

**Import for datetime:** Add `from datetime import datetime` at top of file.

Do NOT modify the existing search or resolve endpoints.
  </action>
  <verify>
    <automated>cd /Users/ekariz/Projects/AMBAND/DOCiD/project && python -c "
import sys; sys.path.insert(0, 'backend')
from app.routes.rrid import rrid_bp
rules = [r.rule for r in rrid_bp.deferred_functions] if hasattr(rrid_bp, 'deferred_functions') else []
# Check blueprint has the expected endpoints by examining the source
import inspect
source = inspect.getsource(rrid_bp.__module__ if hasattr(rrid_bp, '__module__') else type(rrid_bp))
print('Has attach route:', '/attach' in open('backend/app/routes/rrid.py').read())
print('Has entity route:', '/entity' in open('backend/app/routes/rrid.py').read())
print('Has delete route:', 'rrid_id' in open('backend/app/routes/rrid.py').read())
print('Has IntegrityError import:', 'IntegrityError' in open('backend/app/routes/rrid.py').read())
print('Has validate_rrid import:', 'validate_rrid' in open('backend/app/routes/rrid.py').read())
print('Has jwt_required on all:', open('backend/app/routes/rrid.py').read().count('jwt_required') >= 5)
"
    </automated>
    <manual>All six print statements output True</manual>
  </verify>
  <done>
  - POST /api/v1/rrid/attach accepts rrid, entity_type, entity_id in JSON body, resolves via SciCrunch, creates DocidRrid row, returns serialized row with 201
  - Duplicate attach returns 409 with readable message like "RRID:SCR_012345 is already attached to this publication"
  - GET /api/v1/rrid/entity?entity_type=publication&entity_id=42 returns flat JSON array of serialized DocidRrid rows (or empty array)
  - DELETE /api/v1/rrid/123 removes row and returns 200 with success message; nonexistent ID returns 404
  - All three endpoints decorated with @jwt_required()
  </done>
</task>

<task type="auto">
  <name>Task 2: Add RRID cascade deletion to publication and organization delete flows</name>
  <files>backend/app/routes/publications.py</files>
  <action>
Modify the existing `delete_publication` function in `backend/app/routes/publications.py` to cascade-delete associated RRID rows in the same transaction.

**Add import at top of file:**
Add `DocidRrid` to the existing model imports line:
```python
from app.models import Publications,PublicationFiles,...,DocidRrid
```

**1. Publication cascade (ATTACH-07):**

In the `delete_publication` function, inside the `# Delete related records first (cascading delete)` try block (around line 2595-2616), add RRID deletion BEFORE the existing organization deletion line. Insert:

```python
# Delete attached RRIDs for this publication
DocidRrid.query.filter_by(entity_type='publication', entity_id=publication_id).delete()
```

This must go BEFORE `PublicationOrganization.query.filter_by(publication_id=publication_id).delete()` because we also need to cascade org RRIDs.

**2. Publication organization cascade (ATTACH-08):**

In the same `delete_publication` function, BEFORE the `PublicationOrganization.query.filter_by(publication_id=publication_id).delete()` line, add logic to find all publication_organization IDs for this publication and delete their RRID rows:

```python
# Delete attached RRIDs for this publication's organizations
publication_organization_ids = [
    org.id for org in PublicationOrganization.query.filter_by(
        publication_id=publication_id
    ).all()
]
if publication_organization_ids:
    DocidRrid.query.filter(
        DocidRrid.entity_type == 'organization',
        DocidRrid.entity_id.in_(publication_organization_ids)
    ).delete(synchronize_session='fetch')
```

The final order in the cascade block should be:
1. Delete publication RRIDs (entity_type='publication')
2. Fetch publication_organization IDs
3. Delete organization RRIDs (entity_type='organization') for those IDs
4. Delete publication organizations (existing line)
5. (rest of existing cascade: creators, funders, projects, files, documents, audit trail)

All operations happen in the same `db.session` transaction — commit is already at the end.

**Important:** The existing `db.session.rollback()` in the except block already covers failure scenarios.
  </action>
  <verify>
    <automated>cd /Users/ekariz/Projects/AMBAND/DOCiD/project && python -c "
content = open('backend/app/routes/publications.py').read()
print('DocidRrid imported:', 'DocidRrid' in content)
print('Publication RRID cascade:', \"entity_type='publication'\" in content or 'entity_type=.publication.' in content)
print('Organization RRID cascade:', \"entity_type='organization'\" in content or 'entity_type=.organization.' in content or 'organization' in content.split('DocidRrid')[1] if 'DocidRrid' in content else False)
print('Cascade before org delete:', content.index('DocidRrid') < content.index('PublicationOrganization.query.filter_by(publication_id=publication_id).delete()'))
"
    </automated>
    <manual>All four print statements output True, confirming RRID cascade deletion is added before organization deletion in the delete_publication function</manual>
  </verify>
  <done>
  - Deleting a publication removes all docid_rrids rows where entity_type='publication' AND entity_id=publication_id
  - Deleting a publication also removes all docid_rrids rows where entity_type='organization' AND entity_id IN (publication_organization IDs for that publication)
  - Both cascades happen in the same transaction as the existing cascade deletions
  - No orphaned RRID rows remain after publication deletion
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full phase:

1. **Endpoint existence:** All five RRID endpoints (search, resolve, attach, entity, delete) exist in the Flask URL map under /api/v1/rrid
2. **Import integrity:** rrid.py imports db, IntegrityError, validate_rrid, resolve_rrid, DocidRrid, datetime
3. **Cascade integrity:** publications.py imports DocidRrid and has cascade deletion logic before PublicationOrganization deletion
4. **JWT protection:** All 5 endpoints in rrid.py are decorated with @jwt_required()
5. **No regressions:** Existing search and resolve endpoints are unchanged

```bash
cd /Users/ekariz/Projects/AMBAND/DOCiD/project && python -c "
import sys; sys.path.insert(0, 'backend')
rrid_source = open('backend/app/routes/rrid.py').read()
pub_source = open('backend/app/routes/publications.py').read()

# Endpoint checks
assert '/attach' in rrid_source, 'Missing attach route'
assert '/entity' in rrid_source, 'Missing entity route'
assert 'rrid_id' in rrid_source, 'Missing delete route'
assert rrid_source.count('jwt_required') >= 5, 'Not all endpoints have JWT protection'

# Import checks
assert 'IntegrityError' in rrid_source, 'Missing IntegrityError import'
assert 'validate_rrid' in rrid_source, 'Missing validate_rrid import'
assert 'from app import db' in rrid_source, 'Missing db import'

# Cascade checks
assert 'DocidRrid' in pub_source, 'Missing DocidRrid import in publications.py'

print('ALL PHASE 4 VERIFICATIONS PASSED')
"
```
</verification>

<success_criteria>
- POST /api/v1/rrid/attach creates RRID rows with resolved metadata from SciCrunch
- Duplicate attachments return 409 Conflict (not 500)
- GET /api/v1/rrid/entity returns filtered RRID list for any entity
- DELETE /api/v1/rrid/<id> removes individual RRID rows
- Publication deletion cascades to remove associated publication and organization RRID rows
- All endpoints require JWT authentication
</success_criteria>

<output>
After completion, create `.planning/phases/04-flask-blueprint-attach-list-detach/04-01-SUMMARY.md`
</output>
