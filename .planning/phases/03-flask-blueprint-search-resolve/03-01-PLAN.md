---
phase: 03-flask-blueprint-search-resolve
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models.py
  - backend/app/routes/rrid.py
  - backend/app/__init__.py
autonomous: true
requirements: [INFRA-07, INFRA-08, SEARCH-01, SEARCH-02, SEARCH-03, SEARCH-04, SEARCH-05, SEARCH-06]
must_haves:
  truths:
    - "GET /api/v1/rrid/search?q=flow+cytometry returns a JSON array of resources with scicrunch_id, name, description, url, types, rrid fields"
    - "GET /api/v1/rrid/search?q=flow+cytometry&type=software returns only software resources; omitting type defaults to core facility"
    - "GET /api/v1/rrid/search without q parameter returns HTTP 400"
    - "GET /api/v1/rrid/resolve?rrid=RRID:SCR_012345 returns flattened response with properCitation, mentions, name, description, url, resource_type, last_resolved_at, stale"
    - "GET /api/v1/rrid/resolve?entity_type=user_account returns HTTP 400 — only publication and organization accepted"
    - "Both endpoints return 401 when JWT is missing or invalid"
    - "SciCrunch failures produce HTTP 502 with generic error message, never exposing internals"
  artifacts:
    - path: "backend/app/routes/rrid.py"
      provides: "RRID search and resolve Flask blueprint"
      min_lines: 60
    - path: "backend/app/models.py"
      provides: "ALLOWED_ENTITY_TYPES frozenset on DocidRrid"
      contains: "ALLOWED_ENTITY_TYPES"
    - path: "backend/app/__init__.py"
      provides: "rrid_bp registration under /api/v1/rrid"
      contains: "rrid_bp"
  key_links:
    - from: "backend/app/routes/rrid.py"
      to: "backend/app/service_scicrunch.py"
      via: "search_rrid_resources and resolve_rrid function calls"
      pattern: "search_rrid_resources|resolve_rrid"
    - from: "backend/app/routes/rrid.py"
      to: "backend/app/models.py"
      via: "DocidRrid.ALLOWED_ENTITY_TYPES import"
      pattern: "DocidRrid\\.ALLOWED_ENTITY_TYPES"
    - from: "backend/app/__init__.py"
      to: "backend/app/routes/rrid.py"
      via: "Blueprint registration"
      pattern: "register_blueprint\\(rrid_bp"
---

<objective>
Create the RRID Flask blueprint with search and resolve endpoints, register it in the application factory, and add the entity type allowlist to the DocidRrid model.

Purpose: Expose the Phase 2 SciCrunch service layer as HTTP endpoints so authenticated code (and eventually the frontend proxy) can search RRID resources by keyword/type and resolve any known RRID to canonical metadata.

Output: `backend/app/routes/rrid.py` with two GET endpoints, `ALLOWED_ENTITY_TYPES` on `DocidRrid`, blueprint registered in `app/__init__.py`.
</objective>

<execution_context>
@/Users/ekariz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekariz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-flask-blueprint-search-resolve/03-CONTEXT.md
@.planning/phases/03-flask-blueprint-search-resolve/03-RESEARCH.md
@.planning/phases/02-service-layer/02-01-SUMMARY.md
@.planning/phases/02-service-layer/02-02-SUMMARY.md
@backend/app/routes/figshare.py (blueprint pattern reference)
@backend/app/__init__.py (registration pattern)
@backend/app/service_scicrunch.py (service functions to call)
@backend/app/models.py (DocidRrid model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ALLOWED_ENTITY_TYPES to DocidRrid and create RRID blueprint with search endpoint</name>
  <files>
    backend/app/models.py
    backend/app/routes/rrid.py
  </files>
  <action>
**Step 1 — Add ALLOWED_ENTITY_TYPES to DocidRrid model:**

In `backend/app/models.py`, add a class-level constant to the `DocidRrid` class:

```python
ALLOWED_ENTITY_TYPES = frozenset({'publication', 'organization'})
```

Place it as the first line inside the class body, before `__tablename__`. This is the single source of truth for entity type validation, matching the DB-level CHECK constraint.

**Step 2 — Create `backend/app/routes/rrid.py`:**

Create the new blueprint file following the `figshare.py` pattern:

1. Module-level imports: `logging`, `Flask` (`Blueprint`, `request`, `jsonify`), `flask_jwt_extended` (`jwt_required`), `app.models` (`DocidRrid`), `app.service_scicrunch` (`search_rrid_resources`, `resolve_rrid`).
2. Module-level logger: `logger = logging.getLogger(__name__)`
3. Blueprint object: `rrid_bp = Blueprint('rrid', __name__, url_prefix='/api/v1/rrid')`

**Search endpoint** — `GET /search`:

```python
@rrid_bp.route('/search', methods=['GET'])
@jwt_required()
def search_resources():
```

Implementation:
- Read `q` from `request.args.get('q')`. If missing/empty, return `jsonify({'error': 'Missing required parameter: q'}), 400`.
- Read `type` from `request.args.get('type')`. Pass as-is to service (None means service defaults to `core_facility`).
- Call `search_rrid_resources(keyword_query, resource_type_filter)`.
- If error returned:
  - If `error.get('error', '')` starts with `'Invalid resource type'`, return `jsonify({'error': f"Invalid resource type: {resource_type_filter}"}), 400`.
  - Otherwise return `jsonify({'error': 'Search service unavailable'}), 502`.
- On success, return `jsonify(search_results), 200`. Empty list returns `200 []` per CONTEXT.md decision.

Use declarative variable names: `keyword_query`, `resource_type_filter`, `search_results`, `search_error`.
  </action>
  <verify>
    <automated>cd /Users/ekariz/Projects/AMBAND/DOCiD/project && python -c "from app.routes.rrid import rrid_bp; print('Blueprint:', rrid_bp.name, rrid_bp.url_prefix)" && python -c "from app.models import DocidRrid; print('ALLOWED_ENTITY_TYPES:', DocidRrid.ALLOWED_ENTITY_TYPES)"</automated>
    <manual>Confirm rrid_bp imports cleanly and ALLOWED_ENTITY_TYPES is a frozenset with publication and organization</manual>
  </verify>
  <done>
    - `DocidRrid.ALLOWED_ENTITY_TYPES` is `frozenset({'publication', 'organization'})`
    - `rrid_bp` Blueprint exists with name 'rrid' and url_prefix '/api/v1/rrid'
    - Search endpoint handler `search_resources` is defined with `@jwt_required()` and `@rrid_bp.route('/search', methods=['GET'])`
    - Missing `q` returns 400, invalid type returns 400, SciCrunch failure returns 502, success returns 200 with JSON array
  </done>
</task>

<task type="auto">
  <name>Task 2: Add resolve endpoint and register blueprint in app factory</name>
  <files>
    backend/app/routes/rrid.py
    backend/app/__init__.py
  </files>
  <action>
**Step 1 — Add resolve endpoint to `backend/app/routes/rrid.py`:**

```python
@rrid_bp.route('/resolve', methods=['GET'])
@jwt_required()
def resolve_rrid_endpoint():
```

Implementation:
- Read `rrid` from `request.args.get('rrid')`. If missing, return `jsonify({'error': 'Missing required parameter: rrid'}), 400`.
- Read `entity_type` from `request.args.get('entity_type')` and `entity_id` from `request.args.get('entity_id')`.
- **Partial entity context check:** If one is provided without the other (`bool(entity_type) != bool(entity_id_raw)`), return `jsonify({'error': 'Both entity_type and entity_id are required when either is provided'}), 400`.
- **Entity type allowlist check:** If `entity_type` is provided and not in `DocidRrid.ALLOWED_ENTITY_TYPES`, return `jsonify({'error': f"Invalid entity_type: {entity_type}"}), 400`.
- **entity_id type conversion:** Wrap `int(entity_id_raw)` in try/except `ValueError` — return `jsonify({'error': 'Invalid entity_id: must be an integer'}), 400` on failure.
- Call `resolve_rrid(rrid_param, entity_type, entity_id)` from `service_scicrunch`.
- **Error mapping from service (data, error) tuple:**
  - If `resolve_error.get('error') == 'Invalid RRID format'`, return `jsonify({'error': 'Invalid RRID format'}), 400`.
  - If `'not found'` in `resolve_error.get('detail', '').lower()` or `'could not resolve'` in detail, return `jsonify({'error': f"RRID not found: {rrid_param}"}), 404`.
  - Otherwise return `jsonify({'error': 'Search service unavailable'}), 502`.
- **Flatten nested service response:** The service returns `{"resolved": {...7 fields...}, "last_resolved_at": "...", "cached": bool, "stale": bool}`. Extract `resolved_result['resolved']` as `canonical_metadata`, then build flat response:

```python
flat_response = {
    **canonical_metadata,
    'last_resolved_at': resolved_result.get('last_resolved_at'),
    'stale': resolved_result.get('stale', False),
}
return jsonify(flat_response), 200
```

Use declarative variable names: `rrid_param`, `entity_type`, `entity_id_raw`, `entity_id`, `resolved_result`, `resolve_error`, `canonical_metadata`, `flat_response`.

**Step 2 — Register blueprint in `backend/app/__init__.py`:**

1. Add import line alongside existing blueprint imports (near the `from app.routes.figshare import figshare_bp` block):
   ```python
   from app.routes.rrid import rrid_bp
   ```

2. Add registration line in the `register_blueprint` block, after the last existing `register_blueprint` call:
   ```python
   app.register_blueprint(rrid_bp, url_prefix='/api/v1/rrid')
   ```

Follow the exact pattern of existing blueprints — import at top of `create_app()`, register in the blueprint block. Pass `url_prefix` in both the Blueprint constructor and `register_blueprint()` per project convention.
  </action>
  <verify>
    <automated>cd /Users/ekariz/Projects/AMBAND/DOCiD/project && python -c "
from app import create_app
app = create_app()
with app.app_context():
    rules = [rule.rule for rule in app.url_map.iter_rules() if '/rrid/' in rule.rule]
    print('RRID routes:', rules)
    assert '/api/v1/rrid/search' in rules, 'search route missing'
    assert '/api/v1/rrid/resolve' in rules, 'resolve route missing'
    print('All RRID routes registered successfully')
"</automated>
    <manual>Confirm both /api/v1/rrid/search and /api/v1/rrid/resolve appear in the app URL map</manual>
  </verify>
  <done>
    - Resolve endpoint handler `resolve_rrid_endpoint` is defined with `@jwt_required()` and `@rrid_bp.route('/resolve', methods=['GET'])`
    - Missing `rrid` returns 400, invalid RRID format returns 400, RRID not found returns 404, SciCrunch failure returns 502
    - Partial entity context (one without the other) returns 400
    - Invalid entity_type returns 400
    - Non-numeric entity_id returns 400
    - Successful resolve returns flattened JSON with 7 canonical fields + last_resolved_at + stale at top level
    - Blueprint registered in `app/__init__.py` — both `/api/v1/rrid/search` and `/api/v1/rrid/resolve` respond without 404
  </done>
</task>

</tasks>

<verification>
1. Both routes registered: `python -c "from app import create_app; app = create_app(); [print(r) for r in app.url_map.iter_rules() if '/rrid/' in r.rule]"` shows `/api/v1/rrid/search` and `/api/v1/rrid/resolve`
2. `DocidRrid.ALLOWED_ENTITY_TYPES` is `frozenset({'publication', 'organization'})`
3. Blueprint file exists at `backend/app/routes/rrid.py` with both endpoint handlers
4. `app/__init__.py` contains `rrid_bp` import and `register_blueprint(rrid_bp` call
</verification>

<success_criteria>
- Both `/api/v1/rrid/search` and `/api/v1/rrid/resolve` appear in the Flask URL map
- Search endpoint validates `q` parameter, delegates to `search_rrid_resources`, returns flat JSON array
- Resolve endpoint validates `rrid` parameter, validates entity params, delegates to `resolve_rrid`, returns flattened response
- Entity type validation uses `DocidRrid.ALLOWED_ENTITY_TYPES` as single source of truth
- Both endpoints are protected with `@jwt_required()`
- Error responses use generic messages, never exposing SciCrunch internals
</success_criteria>

<output>
After completion, create `.planning/phases/03-flask-blueprint-search-resolve/03-01-SUMMARY.md`
</output>
