---
phase: 02-service-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/config.py
  - backend/app/service_scicrunch.py
autonomous: true
requirements:
  - INFRA-05
  - INFRA-06
  - SEARCH-07
  - SEARCH-08

must_haves:
  truths:
    - "SCICRUNCH_API_KEY is loaded from environment into Flask app.config and never exposed with NEXT_PUBLIC_ prefix"
    - "service_scicrunch.py defines SCICRUNCH_SEARCH_BASE (api.scicrunch.io) and SCICRUNCH_RESOLVER_BASE (scicrunch.org) as separate constants"
    - "validate_rrid accepts RRID:SCR_012345, RRID:AB_123456789, RRID:CVCL_0001 and auto-prepends RRID: when absent; rejects non-matching strings"
    - "validate_rrid normalizes case-insensitive input to uppercase (rrid:scr_012345 becomes RRID:SCR_012345)"
    - "search_rrid_resources sends requests to api.scicrunch.io with apikey header, using term queries for exact RRID lookups"
    - "search_rrid_resources returns (data, None) tuple on success with normalized fields: scicrunch_id, name, description, url, types, rrid"
  artifacts:
    - path: "backend/config.py"
      provides: "SCICRUNCH_API_KEY config entry"
      contains: "SCICRUNCH_API_KEY"
    - path: "backend/app/service_scicrunch.py"
      provides: "RRID validation and search functions"
      min_lines: 100
      exports: ["validate_rrid", "search_rrid_resources"]
  key_links:
    - from: "backend/app/service_scicrunch.py"
      to: "backend/config.py"
      via: "Flask app.config['SCICRUNCH_API_KEY']"
      pattern: "app\\.config\\[.SCICRUNCH_API_KEY.\\]"
    - from: "backend/app/service_scicrunch.py"
      to: "api.scicrunch.io"
      via: "requests.Session HTTP call with apikey header"
      pattern: "SCICRUNCH_SEARCH_BASE"
---

<objective>
Create the foundation of service_scicrunch.py -- RRID format validation and SciCrunch Elasticsearch search -- plus the server-side API key configuration.

Purpose: Establish the service module with its HTTP session, URL constants, error tuple pattern, RRID validation logic, and search function so that Phase 3 blueprint can call search_rrid_resources directly.

Output: `backend/app/service_scicrunch.py` (partial -- validation + search), updated `backend/config.py`
</objective>

<execution_context>
@/Users/ekariz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekariz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-service-layer/02-CONTEXT.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
@backend/config.py
@backend/app/__init__.py
@backend/app/models.py (DocidRrid class)
@backend/app/routes/ror.py (reference pattern for external API calls)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SCICRUNCH_API_KEY to config and create service_scicrunch.py with validation + search</name>
  <files>backend/config.py, backend/app/service_scicrunch.py</files>
  <action>
**1. Update backend/config.py:**
Add `SCICRUNCH_API_KEY = os.getenv('SCICRUNCH_API_KEY')` to the Config class (after the CSTR block, before CORDRA). Do NOT add a `NEXT_PUBLIC_` variant anywhere.

**2. Create backend/app/service_scicrunch.py with these components:**

**Module-level constants and setup:**
- `SCICRUNCH_SEARCH_BASE = "https://api.scicrunch.io/elastic/v1"` (search domain)
- `SCICRUNCH_RESOLVER_BASE = "https://scicrunch.org"` (resolver domain -- used by Plan 02)
- `SCICRUNCH_ES_INDEX = "RIN_Tool_pr"` (the Elasticsearch index to query)
- `RRID_PATTERN = re.compile(r'^(RRID:)?(SCR_\d+|AB_\d+|CVCL_\d+)$', re.IGNORECASE)` regex for validation
- `RESOURCE_TYPE_MAP` dict mapping user-friendly names to SciCrunch type values:
  - `"core_facility"` -> filter value for core facility resources
  - `"software"` -> filter value for software resources
  - `"antibody"` -> filter value for antibody resources
  - `"cell_line"` -> filter value for cell line resources
- `DEFAULT_RESOURCE_TYPE = "core_facility"` (DOCiD's primary use case)
- `SEARCH_RESULT_LIMIT = 20`
- `REQUEST_TIMEOUT = 30` (seconds -- accommodates SciCrunch variable latency up to 25s)
- Module-level `requests.Session()` with `HTTPAdapter` from `requests.adapters` configured with `max_retries=3` (use `urllib3.util.retry.Retry` with `backoff_factor=0.5`, `status_forcelist=[502, 503, 504]`). Mount adapter on both `https://` and `http://`.

**Helper function: `_get_api_key()`**
- Import `current_app` from flask
- Return `current_app.config.get('SCICRUNCH_API_KEY')`
- If key is None or empty, return None (caller decides how to handle)

**Function: `validate_rrid(rrid_string)`**
- Strip whitespace from input
- Match against `RRID_PATTERN`
- If no match: return `(None, {"error": "Invalid RRID format", "detail": f"'{rrid_string}' does not match RRID:SCR_*, RRID:AB_*, or RRID:CVCL_* patterns"})`
- If match: extract the identifier part (group 2), uppercase it, prepend "RRID:" -> normalized form
- Return `(normalized_rrid, None)` on success

**Function: `search_rrid_resources(query, resource_type=None)`**
- If `resource_type` is None, default to `DEFAULT_RESOURCE_TYPE`
- Validate `resource_type` is a key in `RESOURCE_TYPE_MAP`; if not, return error tuple
- Get API key via `_get_api_key()`; if None, return `(None, {"error": "SciCrunch API key not configured"})`
- Build Elasticsearch query body:
  - For keyword search (when query does NOT look like an RRID -- i.e., does not match RRID_PATTERN): use a `bool` query with `must` containing a `query_string` on the query text, plus `filter` for the resource type
  - For exact RRID lookup (when query matches RRID_PATTERN): use a `term` query on the appropriate RRID field (NOT `query_string` -- this is critical to avoid colon-escaping failures per SEARCH-08)
  - Set `size` to `SEARCH_RESULT_LIMIT`
- POST to `{SCICRUNCH_SEARCH_BASE}/{SCICRUNCH_ES_INDEX}/_search` with:
  - Headers: `{"apikey": api_key, "Content-Type": "application/json"}`
  - JSON body: the ES query
  - Timeout: `REQUEST_TIMEOUT`
- On success (HTTP 200): extract hits from response, normalize each hit to:
  ```python
  {
      "scicrunch_id": hit["_id"],
      "name": hit["_source"].get("item", {}).get("name", ""),
      "description": hit["_source"].get("item", {}).get("description", ""),
      "url": hit["_source"].get("item", {}).get("url", ""),
      "types": hit["_source"].get("item", {}).get("types", []),
      "rrid": f"RRID:{hit['_source'].get('item', {}).get('curie', '')}"
  }
  ```
  Note: The exact field paths in SciCrunch ES response may vary. Use `.get()` chains defensively. The above is the expected shape -- adjust field paths based on actual SciCrunch ES response structure if needed.
- Return `(results_list, None)` on success
- On HTTP error: return `(None, {"error": "SciCrunch search failed", "status_code": response.status_code, "detail": response.text[:500]})`
- On `requests.RequestException`: return `(None, {"error": "SciCrunch search request failed", "detail": str(e)})`

**Important constraints:**
- Use `(data, error)` tuple pattern for ALL return values per user decision
- Send `apikey` header ONLY to search domain, NEVER to resolver domain
- Use `term` queries for exact RRID lookups, `query_string` only for keyword searches
- All variable names must be declarative (per user's global CLAUDE.md)
- Add logging via Python `logging` module (module-level logger: `logger = logging.getLogger(__name__)`)
  </action>
  <verify>
    <automated>cd /Users/ekariz/Projects/AMBAND/DOCiD/project && python -c "
import sys; sys.path.insert(0, 'backend');
from app.service_scicrunch import validate_rrid, search_rrid_resources, SCICRUNCH_SEARCH_BASE, SCICRUNCH_RESOLVER_BASE, SCICRUNCH_ES_INDEX, RESOURCE_TYPE_MAP;
# Test validation
assert validate_rrid('RRID:SCR_012345') == ('RRID:SCR_012345', None), 'SCR valid';
assert validate_rrid('AB_123456789')[0] == 'RRID:AB_123456789', 'AB auto-prepend';
assert validate_rrid('rrid:cvcl_0001')[0] == 'RRID:CVCL_0001', 'case normalize';
assert validate_rrid('INVALID_123')[1] is not None, 'reject invalid';
assert validate_rrid('RRID:XYZ_999')[1] is not None, 'reject unknown prefix';
# Test constants
assert 'api.scicrunch.io' in SCICRUNCH_SEARCH_BASE;
assert 'scicrunch.org' in SCICRUNCH_RESOLVER_BASE;
assert SCICRUNCH_ES_INDEX == 'RIN_Tool_pr';
assert 'core_facility' in RESOURCE_TYPE_MAP;
print('ALL CHECKS PASSED')
"</automated>
    <manual>Verify backend/config.py has SCICRUNCH_API_KEY line and no NEXT_PUBLIC_ variant exists</manual>
  </verify>
  <done>
- validate_rrid accepts SCR_, AB_, CVCL_ prefixes with/without RRID: prefix, normalizes to uppercase
- validate_rrid rejects strings not matching known RRID patterns
- search_rrid_resources builds correct ES queries (term for RRID, query_string for keywords)
- apikey header sent only to search domain
- SCICRUNCH_API_KEY in config.py, no NEXT_PUBLIC_ exposure
- (data, error) tuple pattern used throughout
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.service_scicrunch import validate_rrid, search_rrid_resources"` -- imports without error
2. Validation tests pass for all 3 prefix families plus rejection of invalid formats
3. `grep -r "NEXT_PUBLIC_SCICRUNCH" backend/` returns zero results
4. Both URL constants reference correct domains
5. `RESOURCE_TYPE_MAP` has all 4 resource types
</verification>

<success_criteria>
- service_scicrunch.py exists with validate_rrid and search_rrid_resources functions
- RRID validation handles all 3 prefix families with auto-prepend and case normalization
- Search function uses term queries for exact RRID lookups (not query_string)
- Config has SCICRUNCH_API_KEY, no frontend exposure
- All functions use (data, error) tuple return pattern
</success_criteria>

<output>
After completion, create `.planning/phases/02-service-layer/02-01-SUMMARY.md`
</output>
